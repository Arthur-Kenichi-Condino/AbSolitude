//  MemoryManagement.cs
//  Fornece métodos utilitários para gerenciar memória e disparar coleta de lixo no Unity.
//  Inclui lógica para coleta de lixo automática e manual baseada em limites de uso de memória [generated by Copilot]
#if UNITY_EDITOR
    #define ENABLE_LOG_DEBUG
#endif
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.Scripting;
namespace AKCondinoO{
    ///<summary>
    ///  Classe estática para lidar com gerenciamento de memória e lógica de coleta de lixo [generated by Copilot]
    ///</summary>
    internal static class MemoryManagement{
     const long kCollectAfterAllocating=85L*1024L;//  Limite de memória (em bytes) após o qual a coleta de lixo é considerada [generated by Copilot]
      const float kCollectAfterAllocatingCollectionTimeInterval=60.0f;//  Intervalo de tempo (em segundos) para aguardar antes de coletar após atingir o limite de alocação [generated by Copilot]
     static long nextCollectAt=0L;//  Próximo limite de memória para disparar coleta [generated by Copilot]
     const long kHighWater=2L*1024L*1024L*1024L;//  Limite máximo de uso de memória (em bytes) para disparar coleta imediata [generated by Copilot]
      const float kHighWaterCollectionTimeInterval=30.0f;//  Intervalo de tempo (em segundos) para aguardar antes de coletar após atingir o limite máximo [generated by Copilot]
     const float manualGarbageCollectionTimeInterval=90.0f;//  Intervalo de tempo (em segundos) para coleta de lixo manual [generated by Copilot]
     internal static float lastManualGarbageCollectionTime=-1;//  Última vez que a coleta de lixo manual foi realizada [generated by Copilot]
     static long lastFrameMemory=0L;//  Uso de memória no último frame [generated by Copilot]
        ///<summary>
        ///  Verifica o uso de memória e dispara coleta de lixo com base nos limites e intervalos definidos [generated by Copilot]
        ///</summary>
        ///<param name="time">Tempo atual em segundos [generated by Copilot]</param>
        internal static void CallGC(float time){
         bool collectNow=false;
         bool immediate=false;
         long mem=Profiler.GetMonoUsedSizeLong();
         if(mem<lastFrameMemory){
          //Log.DebugMessage("GC happened mem:"+mem+"; was:"+lastFrameMemory);
          nextCollectAt=mem+kCollectAfterAllocating;
         }
         if(mem>=nextCollectAt){
          if(!(time-lastManualGarbageCollectionTime<=kCollectAfterAllocatingCollectionTimeInterval)){
           Log.DebugMessage("mem>=nextCollectAt:Trigger GC");
           collectNow|=true;
          }
         }
         if(mem>kHighWater){
          if(!(time-lastManualGarbageCollectionTime<=kHighWaterCollectionTimeInterval)){
           Log.Warning("mem>kHighWater:Trigger immediate GC");
           collectNow|=true;
           immediate|=true;
          }
         }
         if(lastManualGarbageCollectionTime>=0f){
          if(!(time-lastManualGarbageCollectionTime<=manualGarbageCollectionTimeInterval)){
           Log.DebugMessage("manualGarbageCollectionTimeInterval:Trigger GC");
           collectNow|=true;
          }
         }
         if(collectNow){
          Log.DebugMessage("call GC mem:"+mem);
          if(immediate||!GarbageCollector.isIncremental){
           GCSettings.LargeObjectHeapCompactionMode=GCLargeObjectHeapCompactionMode.CompactOnce;
           GC.Collect(GC.MaxGeneration,GCCollectionMode.Forced,true,true);
           GC.WaitForPendingFinalizers();
          }else{
           GarbageCollector.CollectIncremental();
          }
          Log.DebugMessage("post GC call mem:"+mem);
          lastManualGarbageCollectionTime=time;
          nextCollectAt=mem+kCollectAfterAllocating;
         }
         lastFrameMemory=mem;
        }
        ///<summary>
        ///  Tenta limpar os campos de um objeto usando reflexão. Ignora campos constantes e tipos primitivos [generated by Copilot]
        ///</summary>
        ///<param name="this">Objeto a ser limpo [generated by Copilot]</param>
        ///<param name="flags">Flags de binding para seleção dos campos [generated by Copilot]</param>
        internal static void SuperDestroy(this object @this,BindingFlags flags){
         foreach(FieldInfo field in @this.GetType().GetFields(flags)){
          Log.DebugMessage("SuperDestroy:field:"+field);
          if(field.IsLiteral&&!field.IsInitOnly){
           Log.DebugMessage("SuperDestroy:ignore const: "+field.Name+" of type "+field.FieldType);
           continue;
          }
          if(field.FieldType.IsPrimitive){
           Log.DebugMessage("SuperDestroy:ignore primitive: "+field.Name+" of type "+field.FieldType);
           continue;
          }
         }
         Log.Warning("TO DO:implementação incompleta");
        }
    }
}