#if UNITY_EDITOR
    #define ENABLE_LOG_DEBUG
#endif
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
namespace AKCondinoO{
    ///<summary>
    ///  Container base para tarefas em segundo plano, gerencia sinais de sincronização e descarte de recursos [generated by Copilot]
    ///</summary>
    internal abstract class BackgroundContainer:IDisposable{
     internal readonly ManualResetEvent backgroundData=new ManualResetEvent( true);//  Sinal para indicar que os dados de fundo estão prontos [generated by Copilot]
     internal readonly   AutoResetEvent foregroundData=new   AutoResetEvent(false);//  Sinal para indicar que os dados de primeiro plano estão prontos [generated by Copilot]
        ///<summary>
        ///  Verifica se a tarefa foi concluída, aguardando o sinal ou o tempo limite [generated by Copilot]
        ///  Se o tempo limite for menor que 0, espera indefinidamente.
        ///</summary>
        ///<param name="isRunning">Função que indica se está rodando [generated by Copilot]</param>
        ///<param name="millisecondsTimeout">Tempo limite em milissegundos [generated by Copilot]... Se o tempo limite for menor que 0, espera indefinidamente</param>
        internal bool IsCompleted(Func<bool>isRunning,int millisecondsTimeout=0){
         if(millisecondsTimeout<0&&isRunning.Invoke()!=true){//  Invoca uma função para checagem de que se Threads ainda estão em execução
          return true;
         }
         return backgroundData.WaitOne(millisecondsTimeout);//  Aguarda o sinal de conclusão ou o tempo limite [generated by Copilot]
        }
     protected bool disposed=false;//  Indica se o objeto já foi descartado [generated by Copilot]
        ///<summary>
        ///  Descarta os recursos do container [generated by Copilot]
        ///</summary>
        public void Dispose(){
         Dispose(disposing:true);
         GC.SuppressFinalize(this);//  Evita que o finalizador seja chamado [generated by Copilot]
        }
        ///<summary>
        ///  Método protegido para descartar recursos gerenciados e não gerenciados [generated by Copilot]
        ///</summary>
        ///<param name="disposing">Indica se está descartando recursos gerenciados [generated by Copilot]</param>
        protected virtual void Dispose(bool disposing){
         if(disposed)return;
         if(disposing){//  Libera recursos gerenciados [generated by Copilot]
          //  free managed resources here
          backgroundData.Dispose();
          foregroundData.Dispose();
         }
         //  Libera recursos não gerenciados [generated by Copilot]
         //  free unmanaged resources here
         disposed=true;
        }
        ///<summary>
        ///  Finalizador para garantir o descarte dos recursos [generated by Copilot]
        ///</summary>
        ~BackgroundContainer(){
         Dispose(disposing:false);
        }
    }
    ///<summary>
    ///  Classe base abstrata para processamento multithreaded usando containers de fundo [generated by Copilot]
    ///  Um container, derivado de BackgroundContainer, possui dados que são processados em plano de fundo,
    /// e ficam em estado inconsistente (race conditions) com a Thread principal, mas ao final ficam 
    /// seguros quando a Thread der sinal de que o trabalho acabou
    ///</summary>
    internal abstract class BaseMultithreaded<T>where T:BackgroundContainer{
     internal static bool Stopped{
      get{bool tmp;lock(Stop_syn){tmp=Stop_v;      }return tmp;}
      set{         lock(Stop_syn){    Stop_v=value;}if(value){enqueued.Set();}}
     }static bool Stop_v=false;static readonly object Stop_syn=new object();//  Indica se o processamento foi parado [generated by Copilot]... para qualquer novo container dos tipos derivados
     //  Stop_syn é o objeto de sincronização para acesso ao estado de parada [generated by Copilot]
     static readonly AutoResetEvent enqueued=new AutoResetEvent(false);//  Sinaliza quando há tarefas enfileiradas [generated by Copilot]... ou seja, quando há containers a serem processados por threads de processamento no tipo derivado
     static readonly ConcurrentQueue<T>queued=new ConcurrentQueue<T>();//  Fila concorrente de containers para processamento [generated by Copilot]
        ///<summary>
        ///  Agenda um novo container para processamento [generated by Copilot]
        ///</summary>
        ///<param name="next">Container a ser agendado [generated by Copilot]</param>
        internal static void Schedule(T next){
         next.backgroundData.Reset();
         next.foregroundData.Set();
         queued.Enqueue(next);//  Adiciona o container à fila para processamento [generated by Copilot]
         enqueued.Set();//  Sinaliza que há uma nova tarefa [generated by Copilot]
        }
        internal static int Clear(){
         int count=queued.Count;
         while(queued.TryDequeue(out T dequeued)){
          dequeued.foregroundData.WaitOne(0);
          dequeued.backgroundData.Set();
         }
         return count;
        }
     static readonly List<BaseMultithreaded<T>>allThreadsStarted=new List<BaseMultithreaded<T>>();
        internal static void Start(BaseMultithreaded<T>[]threads,ConstructorInfo ctorInfo,object[]ctorParams){
         //Log.DebugMessage("BaseMultithreaded<"+typeof(T)+">:threads.Length:"+threads.Length);
         if(Stopped){
          Stopped=false;
         }
         if(threads!=null&&threads.Length>0){
          for(int i=0;i<threads.Length;++i){
                        threads[i]=Start(ctorInfo,ctorParams);
          }
         }
        }
        internal static BaseMultithreaded<T>Start(ConstructorInfo ctorInfo,object[]ctorParams){
         //Log.DebugMessage("BaseMultithreaded<"+typeof(T)+">:start thread");
         if(Stopped){
          Stopped=false;
         }
         BaseMultithreaded<T>thread=(BaseMultithreaded<T>)ctorInfo.Invoke(ctorParams);
         allThreadsStarted.Add(thread);
         return thread;
        }
        internal static bool Stop(params BaseMultithreaded<T>[]allThreads){
         if(Clear()!=0){
          Log.Error(((allThreads!=null&&allThreads.Length>0&&allThreads[0]!=null)?allThreads[0].GetType():"BaseMultithreaded<"+typeof(T)+">")+" will stop with pending work");
         }
         Stopped=true;
         bool result=false;
         if(allThreads!=null&&allThreads.Length>0){
          for(int i=0;i<allThreads.Length;++i){
                     if(allThreads[i]==null){continue;}
                        allThreads[i].Wait();
          }
          result=true;
         }
         if(allThreadsStarted.Count>0){
          foreach(BaseMultithreaded<T>thread in allThreadsStarted){
           thread.Wait();
          }
         }
         allThreadsStarted.Clear();
         return result;
        }
     readonly System.Threading.ThreadPriority priority;
     readonly Task task;
        internal BaseMultithreaded(System.Threading.ThreadPriority priority=System.Threading.ThreadPriority.BelowNormal){
         this.priority=priority;
         Core.threadCount++;
         task=Task.Factory.StartNew(BG,TaskCreationOptions.LongRunning);
        }
     protected T container{get;private set;}
        void BG(){Thread.CurrentThread.IsBackground=false;
         Thread.CurrentThread.Priority=priority;
         ManualResetEvent backgroundData;
           AutoResetEvent foregroundData;
         while(!Stopped){enqueued.WaitOne();if(Stopped){enqueued.Set();goto _Stop;}
          if(queued.TryDequeue(out T dequeued)){
           container=dequeued;
           foregroundData=container.foregroundData;
           backgroundData=container.backgroundData;
           try{
            Renew(dequeued);
           }catch(Exception e){
            Log.Error(e?.Message+"\n"+e?.StackTrace+"\n"+e?.Source);
           }
          }else{
           continue;
          };
          if(queued.Count>0){
           enqueued.Set();
          }
          foregroundData.WaitOne();
          try{
           Execute();
          }catch(Exception e){
           Log.Error(e?.Message+"\n"+e?.StackTrace+"\n"+e?.Source);
          }
          try{
           Release();
          }catch(Exception e){
           Log.Error(e?.Message+"\n"+e?.StackTrace+"\n"+e?.Source);
          }
          backgroundData.Set();
          container=null;
          try{
           Cleanup();//
          }catch(Exception e){
           Log.Error(e?.Message+"\n"+e?.StackTrace+"\n"+e?.Source);
          }
         }
         _Stop:{}
         //Log.DebugMessage("Background task ending gracefully!");
        }
        protected virtual void Renew(T next){}
        protected abstract void Execute();
        protected virtual void Release(){}
        protected virtual void Cleanup(){}
        internal bool IsRunning(){
         return Stopped==false&&task!=null&&!task.IsCompleted;
        }
        internal void Wait(){
         try{
          task.Wait();
          Core.threadCount--;
         }catch(Exception e){
          Log.Error(e?.Message+"\n"+e?.StackTrace+"\n"+e?.Source);
         }
        }
    }
}